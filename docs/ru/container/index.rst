.. _ru-container:

Контейнер (Container)
************************

**Контейнер** — это объект, который используется для получения зависимостей.

Базовое использование
======================

Контейнер может быть синхронным или асинхронным.

* *Асинхронный* контейнер может использовать любые источники зависимостей: поддерживаются как синхронные, так и асинхронные. Синхронные методы вызываются напрямую, и исполнители (executors) не используются, поэтому следует избегать сетевого I/O в синхронных функциях.
* *Синхронный* контейнер может использовать только синхронные источники зависимостей.

Для создания контейнера верхнего уровня нужно вызвать ``make_container`` (или ``make_async_container``). Передайте туда один или несколько провайдеров.

.. code-block:: python

    from dishka import make_container
    container = make_container(provider)

И аналогично для асинхронной версии:

.. code-block:: python

    from dishka import make_async_container

    container = make_async_container(provider)

Если вы не предоставили собственный enum с scopes (областями видимости), будет использоваться стандартный. Корневой контейнер привязан к первой области видимости — по умолчанию Scope.APP.

Чтобы перейти в следующую область видимости, нужно вызвать контейнер как функцию и войти в контекстный менеджер:

.. code-block:: python

    with container() as nested_container:
        pass

или если вы создаёте *асинхронный* контейнер:

.. code-block:: python

    async with container() as nested_container:
        pass

Контейнер необходим для получения объектов. Чтобы это сделать, нужно вызвать метод ``get(DependencyType)`` (и для асинхронного контейнера — также ``await``).
Все полученные зависимости хранятся внутри контейнера соответствующей области видимости (scope) до выхода из этой области. Таким образом, если вызвать ``get`` несколько раз, будет возвращён один и тот же экземпляр. Это правило применяется и к косвенным зависимостям. Несколько зависимостей одного уровня области видимости имеют собственный кеш.

.. code-block:: python

    container = make_container(provider)
    a = container.get(A)
    a = container.get(A)  # same instance

и async:

.. code-block:: python

    container = make_async_container(provider)
    a = await container.get(A)
    a = await container.get(A)  # same instance

При выходе из области видимости кэш зависимостей очищается. Финализация зависимостей выполняется, если вы использовали фабрики генераторов.

Контейнер уровня приложения (*APP*-level) не является контекстным менеджером, поэтому вызовите ``.close()`` при завершении работы вашего приложения.

.. code-block:: python

    container.close()

и async:

.. code-block:: python

    await container.close()

Потокобезопасность (Thread/task safety)
=========================================

Вы можете иметь несколько контейнеров одного и того же уровня (scope) одновременно (кроме самого верхнего уровня) — это безопасно, пока у вас нет зависимостей из предыдущего уровня.

Например, если вы объявили ``SessionPool`` как зависимость уровня *APP*, а затем одновременно переходите в уровень *REQUEST*. Когда вы впервые запрашиваете ``SessionPool`` (напрямую или для другой зависимости), вы не можете гарантировать, что будет создан только один экземпляр этого объекта.

Чтобы избежать такой ситуации, необходимо защитить любой уровень, дочерние зависимости которого могут использоваться конкурентно: передавайте ``lock_factory`` при создании контейнера. Не путайте threading- и asyncio-блокировки: они не взаимозаменяемы, используйте подходящий тип.

.. code-block:: python

    import threading

    container = make_container(provider, lock_factory=threading.Lock):
    with container(lock_factory=threading.Lock) as nested_container:
        ...

.. code-block:: python

    import asyncio

    container = make_async_container(provider, lock_factory=asyncio.Lock)
    async with container(lock_factory=asyncio.Lock) as nested_container:
        ...


.. note::
    Не беспокойтесь, блокировка установлена по умолчанию для контейнера верхнего уровня (``Scope.APP``). Таким образом, если вы не используете другие области видимости (scopes) одновременно, вам не нужно ничего менять. (Например, если вы не используете несколько контейнеров ``Scope.ACTION`` одновременно в рамках одного контейнера ``Scope.REQUEST``).
