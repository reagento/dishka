Внедрение зависимостей (Dependency injection)
************************************************

Что такое Внедрение зависимостей?
==================================

Внедрение зависимостей — это простая идея, которая заключается в том, что если некоторому объекту для работы требуется другой объект, он должен получать его извне, а не создавать или запрашивать его самостоятельно.

Представьте, что у вас есть бизнес-логика, которая использует клиент для работы с удалённым API.

.. code-block:: python

    class Service:
        def action(self):
            client = Client(token)
            client.get_data()

    service = Service()
    service.action()

Здесь ``client`` — это ``зависимость (dependency)``. Представьте, что у вас есть множество методов, работающих с одним и тем же клиентом, и каждый метод знает, как создавать этот клиент. Тогда задумайтесь над следующими вопросами:

* Как они получают ``token``? Должен ли каждый метод читать его самостоятельно?
* Что, если конструктор ``Client`` начнёт требовать больше одного токена? Следует ли нам копировать новые параметры в каждый метод?
* Как нам заменить ``client`` на mock-объект при тестировании этих методов?
* Как понять, какая часть кода может использовать ``client``?
* Как повторно использовать один и тот же ``client``, если он становится stateful (сохраняет состояние)?
* Как управлять разными клиентами в разных сценариях?

Надеюсь, к этому моменту вы уже начали подозревать, что здесь есть проблема. Чтобы решить её, давайте создадим нашу **зависимость** где-то вне этого метода и **внедрим (inject)** её.

Есть три способа это сделать:

1. **Внедрение через параметр (Parameter injection).** Мы можем передать клиент в метод как параметр.

.. code-block:: python

    class Service:
        def action(self, client: Client):
            client.get_data()

    service = Service()
    client = Client(token="1234567890")
    service.action(client)

Это хорошо работает, если у вас не много методов, и они не вызывают друг друга. Однако мы меняем сигнатуры методов, что может привести к масштабным изменениям в коде и становится невозможным, если есть жёсткие требования к интерфейсу объекта.

2. **Внедрение через конструктор (Constructor injectio).** Мы можем передать клиент при создании экземпляра сервиса. Тогда все его методы будут иметь к нему доступ. Это основной способ внедрения зависимостей (DI).

.. code-block:: python

    class Service:
        def __init__(self, client: Client):
            self.client = client

        def action(self):
            self.client.get_data()

    token = os.getenv("TOKEN")
    client = Client(token)
    service = Service(client)
    service.action()

3. **Внедрение через атрибуты (Attribute injection).** Мы можем сохранить атрибут напрямую (или с использованием дополнительных методов) в созданном объекте. Этот подход чаще всего используется в сочетании с внедрением через конструктор для изменения существующих объектов или для разрыва циклических ссылок между объектами.

.. code-block:: python

    class Service:
        client: Client

        def action(self):
            self.client.get_data()

    service = Service()
    service.client = Client(token)
    service.action()

Дополнительно нужно перечислить антипаттерны, которых следует избегать, так как они не решают всех проблем, устраняемых за счёт внедрения зависимостей (DI), хотя могут частично их покрывать:

* *Глобальная переменная.* Хотя она позволяет повторно использовать зависимость и настраивать её вне бизнес-логики, мы ограничены одним экземпляром навсегда. Кроме того, мы не контролируем момент её создания и завершения работы: какой-то код может попытаться использовать её до того, как она будет правильно настроена.

* *Синглтон (Singleton).* По сути, это разновидность глобальной переменной. Он может добавить ленивую инициализацию, но остальные недостатки остаются теми же.

* *Монки-патчинг (Monkey patch).* Например, `mock.patch()`. Позволяет подменять поведение в тестах, но при этом опирается на детали того, как класс импортируется и используется, вместо работы через его интерфейс. Это делает тесты более хрупкими и увеличивает затраты на их поддержку.


Когда вследует внедрять зависимости?
======================================

В простых случаях всё очевидно: у вас есть несколько классов с их зависимостями, и при запуске приложения вы создаёте их и связываете вместе. Однако реальные приложения устроены сложнее. Они оперируют десятками или даже сотнями объектов в разветвлённой иерархии и выполняют параллельные вычисления.

Лучше разделять код, работающий с зависимостями, и код, который их создаёт. Как правило, мы стараемся, чтобы основной код знал как можно меньше о своих зависимостях. Но это не всегда удаётся, поскольку разные объекты живут разное время.

Например, *конфигурация* обычно загружается при запуске приложения, а вот *транзакции БД* (и сами *соединения с БД*) должны создаваться заново для каждого HTTP-запроса. Поэтому избежать создания и освобождения зависимостей внутри обработки запроса не получится. У других зависимостей могут быть свои **области видимости (scopes)**, но чаще всего встречаются всего два варианта: на всё время работы приложения и на время выполнения одного запроса.

Для веб-приложения это может выглядеть так:

.. code-block:: python

    @app.get("/")
    def index(request):
        client = Client(os.getenv("TOKEN"))
        service = Service(client)
        service.action()

    @app.get("/foo")
    def get_foo(request):
        client = Client(os.getenv("TOKEN"))
        service = Service(client)
        service.action()

Сложность заключается в том, как управлять этими зависимостями при большом количестве обработчиков запросов, не теряя при этом возможности их тестирования.

* Один из подходов — создавать все зависимости в middleware (это специальный объект, который фреймворк вызывает для каждого события). На псевдокоде это может выглядеть примерно так:

.. code-block:: python

    def service_creator(request):
        client = Client(os.getenv("TOKEN"))
        service = Service(client)
        request.state.service = Service(client)

    app.setup_middleware(service_creator)

    @app.get("/")
    def index(request):
        service = request.state.service
        service.action()

Решение удобное: обработчики запросов остаются чистыми, а в тестах можно подменять middleware. Однако если у вас много "тяжёлых" объектов (которые дорого создавать), могут возникнуть сложности.

* Второй вариант — вынести создание зависимостей в отдельную фабрику (назовём её **контейнер**) и обращаться к ней прямо в обработчике запроса. При этом middleware можно использовать для передачи контейнера (а заодно стоит проверить, какие ещё механизмы для этого предоставляет фреймворк).

.. code-block:: python

    class Container:
        def get_client(self) -> Client:
            return Client(os.getenv("TOKEN"))

        def get_service(self) -> Service:
            return Service(self.get_client())

    container = Container()
    def container_middleware(request):
        request.state.container = container

    app.setup_middleware(container_middleware)

    @app.get("/")
    def index(request):
        service = request.state.container.get_service()
        service.action()

В отличие от middleware, этот подход позволяет создавать только те объекты, которые действительно нужны. Однако будьте осторожны: если обращаться к контейнеру из обработчиков через глобальную переменную, это усложнит поддержку тестов.

Оба способа позволяют гибко настраивать жизненный цикл объектов: создавать их при каждом запросе или единожды на всё приложение. Также вы можете определить отдельные middleware/контейнеры для продакшена и тестов, что упрощает изоляцию окружений.

Что такое IoC-контейнер (IoC-container)?
=============================

IoC-контейнер — это специальный объект (или фреймворк, предоставляющий такой объект), который поставляет зависимости в соответствии с правилами внедрения зависимостей (DI) и управляет их жизненным циклом. DI-фреймворк — это альтернативное название для таких фреймворков.

Многие ошибочно полагают, что DI возможен только через IoC-контейнеры. На самом деле, зависимости можно передавать напрямую (например, через конструктор). Но в крупных проектах это усложняет код — поэтому, как мы видели ранее, удобнее инкапсулировать логику DI в отдельный объект. Тот самый ``Container`` — это и есть примитивная ручная реализация IoC-контейнера.

Чем больше ваше приложение, тем сложнее становятся фабрики и тем важнее автоматизировать создание контейнера. Для тестирования отдельных компонентов IoC-контейнер может быть избыточным, но он становится критичным для запуска всей системы. К счастью, существуют готовые фреймворки для этих задач. Однако важно не допускать "размазывания" логики контейнера по коду приложения — она должна быть изолирована на границах областей видимости.

Итак, говоря о IoC-контейнере, можно записать следующие идеи:

* IoC-контейнер не обязателен для dependency injection
* Он полезен как вспомогательный инструмент для больших приложений
* Его использование должно быть безопасным в многопоточной среде
* Он должен соблюдать заданные правила для зависимостей (одиночные или множественные экземпляры, разные области времени жизни и т. д.)

Дополнительные требования можно изучить в разделе :ref:`technical-requirements`.

А теперь настало время для **dishka** — реализации IoC-контейнера со всем необходимым функционалом.
