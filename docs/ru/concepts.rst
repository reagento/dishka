.. include:: <isonum.txt>

Ключевые понятия
******************
Dishka — это DI-фреймворк, предназначенный для создания сложных объектов в соответствии с принципом dependency injection (внедрения зависимостей).
Давайте начнём с основных терминов.

Зависимость (Dependency)
==========================
Зависимость — это то, что необходимо для работы определённой части вашего кода.
Если ваш *шлюз базы данных* требует *подключения к БД* для выполнения SQL-запросов, то это подключение является зависимостью для шлюза.
Если ваш класс бизнес-логики требует *шлюз базы данных* или *API-клиент*, то *API-клиент* и *шлюз базы данных* являются зависимостями для бизнес-логики.
В этом примере ``Client`` — это зависимость, а ``Service`` — зависимый компонент.

.. code-block:: python

    class Service:
        def __init__(self, client: Client):
            self.client = client

Зависимость — это просто объект, который требуется другому объекту. Зависимости сами могут иметь свои зависимости — и так далее.

Чтобы соблюдать принцип внедрения зависимостей (Dependency Injection), зависимые объекты должны получать свои зависимости извне, а не создавать или запрашивать их самостоятельно.
Одни и те же классы могут создаваться с разными реализациями их зависимостей — например, в тестах вместо реальных сервисов можно использовать заглушки (mocks).


Область видимости (Scope)
===========================
**Scope (область видимости)** — это время жизни зависимости.
Некоторые зависимости существуют в течение всего времени работы приложения, другие создаются и уничтожаются с каждым запросом.
В более редких случаях требуются объекты с ещё более коротким временем жизни.
Область видимости каждой зависимости задаётся при настройке её создания.

Стандартные области видимости (некоторые опущены):

    ``APP`` |rarr| ``REQUEST`` |rarr| ``ACTION`` |rarr| ``STEP``

Ты решаешь, когда войти в каждую область видимости и выйти из неё, но это делается последовательно.
Если ты попадаешь в область ``APP``, то следующий шаг глубже — войти в область ``REQUEST``.

.. note::
    Область ``APP`` можно использовать для ленивой инициализации синглтонов, а ``REQUEST`` — хорошо подходит для обработки событий, таких как HTTP-запросы или обновления мессенджеров. Вряд ли тебе понадобятся другие области видимости.

В Dishka зависимости ленивые — они создаются при первом запросе.
Если одна и та же зависимость запрашивается несколько раз в рамках одной области видимости (scope), то возвращается один и тот же экземпляр (хотя это можно отключить для каждой зависимости отдельно).
Созданная зависимость сохраняется до выхода из области видимости.
При этом она не просто удаляется, а выполняются соответствующие финализирующие действия (например, вызов close или других методов очистки).
Одну и ту же область видимости можно использовать многократно и параллельно — это позволяет одновременно работать с несколькими независимыми экземплярами объектов.

Каждый объект может зависеть от других объектов из текущей или предыдущих областей видимости (scopes).
Таким образом, если у вас есть ``Config`` с областью видимости *APP* и ``Connection`` с областью видимости *REQUEST*, то
вы не можете создать объект с областью *APP*, который требует ``Connection``,
но можете создать объект с областью *REQUEST*, который зависит от ``Connection`` или ``Config`` (или даже от обоих).

Для веб-приложения область ``APP`` активируется при запуске, а область ``REQUEST`` — для каждого HTTP-запроса.

Вы можете создать свою собственную область видимости, определив класс ``Scope``, если стандартный поток областей не подходит под ваши нужды.

:ref:`Подробнее о пользовательских и пропускаемых областях видимости <ru-scopes>`

Контейнер
==================
**Контейнер** — это объект, который используется для получения зависимостей.

Вы просто вызываете метод ``.get(SomeType)``, и контейнер находит способ предоставить вам экземпляр этого типа.
Сам контейнер не создаёт объекты, а управляет их жизненным циклом и кешированием.
Создание объектов он делегирует провайдерам, которые передаются при его инициализации.

Каждый контейнер связан с определённой областью видимости (scope). Чтобы войти во вложенную область, нужно вызвать его и использовать как контекстный менеджер.
В соответствии с порядком областей, контейнер может предоставлять зависимости из своей и предыдущих областей видимости.

.. code-block:: python

    app_container = make_container(provider1, provider2)  # enter APP scope

    config = app_container.get(Config)  # APP-scoped object

    with container() as request_container:  # enter REQUEST scope
        connection = request_container.get(Connection)  # REQUEST-scoped object
        config = request_container.get(Config)  # APP-scoped object

Асинхронный контейнер работает аналогично, но требует использования async context manager и ожидания (await) результата вызова ``.get()``.

Некоторые контейнеры потокобезопасны (thread/task-safe), а другие — нет: это настраивается при вызове контекстного менеджера.
Для веб-приложений рекомендуется, чтобы контейнер с областью *APP* был потокобезопасным, а для контейнеров с областью *REQUEST* это не требуется (и такое поведение установлено по умолчанию).

:ref:`Подробнее об API контейнера<ru-container>`


Провайдер (Provider)
======================
**Provider** — это объект, члены которого используются для создания зависимостей.
Это обычный объект, но некоторые его атрибуты должны быть помечены специальными декораторами, чтобы контейнер мог их использовать.
Чтобы создать собственный провайдер, нужно унаследоваться от класса ``Provider`` и создать его экземпляр при инициализации контейнера:

.. code-block:: python

    class MyProvider(Provider):
        pass

    container = make_container(MyProvider())


Существует 4 специальные функции:

* ``@provide`` — объявляет фабрику, которая предоставляет зависимость. Может использоваться как декоратор класса или метода. :ref:`Подробнее<ru-provide>`
* ``alias`` — позволяет получать один и тот же объект по разным аннотациями типов. :ref:`Подробнее<ru-alias>`
* ``from_context`` — помечает зависимость как контекстные данные, которые задаются вручную при входе в scope (область видимости). :ref:`Подробнее<ru-from-context>`
* ``@decorate`` — модифицирует или оборачивает объект, уже настроенный в другом ``Provider``. :ref:`Подробнее<ru-decorate>`

Компонент (Component)
============================
**Компонент** — это изолированная группа провайдеров в одном контейнере, идентифицируемая уникальной строкой.
Когда запрашивается зависимость, она ищется только внутри того же компонента, что и её непосредственный зависимый объект, если явно не указано иное.

Такая структура позволяет разрабатывать разные части приложения отдельно, не беспокоясь о совпадении типов.

.. code-block:: python

    class MainProvider(Provider):

        @provide(scope=Scope.APP)
        def foo(self, a: Annotated[int, FromComponent("X")]) -> float:
            return a/10

        @provide(scope=Scope.APP)
        def bar(self, a: int) -> complex:
            return a + 0j


    class AdditionalProvider(Provider):
        component = "X"

        @provide(scope=Scope.APP)
        def foo(self) -> int:
            return 1


    container = make_container(MainProvider(), AdditionalProvider())
    container.get(float)  # returns 0.1
    container.get(complex)  # raises NoFactoryError

:ref:`Подробнее про управление компонентами<ru-components>`