.. include:: <isonum.txt>
.. _ru-scopes:

Управление областями видимости (Scope management)
*****************************************************

В ``dishka`` область видимости (scope) определяет время жизни зависимости. Сначала при создании провайдера вы привязываете зависимость к её области видимости. Затем, при использовании контейнера, вы входите в область видимости, и зависимость сохраняется с момента её первого запроса до выхода из этой области.

Набор областей видимости определяется один раз для контейнера, и провайдеры должны использовать одинаковые области. Вы не ограничены стандартными областями и можете создавать собственные, хотя в этом редко возникает необходимость.

В большинстве случаев достаточно двух областей видимости. ``APP`` (приложение) — обычно активируется при создании контейнера и ``REQUEST`` (запрос) — используется во время обработки какого-либо события:

    ``APP`` |rarr| ``REQUEST``

Однако стандартный набор шире. ``Dishka`` поддерживает *пропускаемые (skipped)* области видимости и включает две дополнительные на всякий случай:

    ``[RUNTIME]`` |rarr| ``APP`` |rarr| ``[SESSION]`` |rarr| ``REQUEST`` |rarr| ``ACTION`` |rarr| ``STEP``

При входе в контекст контейнера вы автоматически переходите в следующую непропускаемую область видимости. Либо в целевую область, если она указана.

Пропускаемые области видимости (Skipped scopes)
==================================================

Пропускаемая область — это та, которая неявно пролетается при углублении в дочерние контейнеры.


Например, стандартные области ``RUNTIME`` и ``SESSION`` помечены как ``skip=True``:

При создании контейнера вы неявно входите в ``APP``-область. Область ``RUNTIME`` всё ещё используется — к ней можно привязывать зависимости, но она активируется автоматически и закрывается при завершении контейнера в ``APP``-области.

.. code-block:: python

    container = make_container(provider)  # APP

В другом случае вы можете войти в область ``RUNTIME``, передав ``start_scope=Scope.RUNTIME`` при входе в контейнер, и тогда вы получите эту область. При дальнейшем углублении вы попадёте в область ``APP``, так как она является следующей подходящей. В этом случае закрытие области ``APP`` не затронет ``RUNTIME``, так как она была явно задана.

.. code-block:: python

    container = make_container(provider, start_scope=Scope.RUNTIME)
    with container() as app_container:
        # RUNTIME -> APP

То же самое происходит, когда вы находитесь в области видимости ``APP``. Если вы просто вызовете ``with container()``, вы пропустите область ``SESSION`` и сразу перейдёте в ``REQUEST``. Оба уровня будут закрыты одновременно. Если же вызовете ``with container(scope=Scope.SESSION)``, вы перейдёте в эту область видимости, а затем сможете войти в ``REQUEST`` следующим вызовом.

.. code-block:: python

    container = make_container(provider)
    with container() as request_container:
        # APP -> Session -> REQUEST
        pass

    with container(scope=Scope.SESSION) as session_container:
        # APP -> Session
        with session_container() as request_container:
            # Session -> REQUEST
            pass

.. note::

    * Область видимости ``RUNTIME`` может быть полезна для добавления зависимостей, которые сохраняются между тестами, пересоздающими приложения.
    * Область видимости ``SESSION`` может быть полезна для объектов, связанных с подключением в веб-сокетах, в то время как обработчик HTTP-запросов попадает прямо в область ``REQUEST``.

Пользовательские области видимости (Custom scopes)
==================================================================

Чтобы создать пользовательский набор областей видимости (scopes), вам необходимо:

* Унаследоваться от ``BaseScope``
* Задать области видимости с помощью ``new_scope()``
* Передать этот класс области видимости в вызов ``make_container`` через аргумент ``scopes=``

.. code-block:: python

    from dishka import BaseScope, Provider, make_container, new_scope

    class MyScope(BaseScope):
        APPLICATION = new_scope("APPLICATION")
        SESSION = new_scope("SESSION", skip=True)
        EVENT = new_scope("EVENT")

    provider = Provider(scope=MyScope.EVENT)
    make_container(provider, scopes=MyScope)
