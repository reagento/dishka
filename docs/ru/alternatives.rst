Альтернативы
*********************

**Dishka** была разработана с учётом потребностей реальных приложений. Доступные возможности описаны в других разделах документации, например, в :ref:`technical-requirements`. Однако на рынке существуют и другие библиотеки.

Для этого анализа мы представили несколько сценариев. Не всем приложениям требуется всё перечисленное, но в какой-то момент их жизненного цикла эти функции могут понадобиться:

* Некоторым приложениям (например, AWS Lambda) не нужно создавать все синглтоны при запуске, так как они обрабатывают лишь несколько запросов.
* В одних приложениях (например, десктопных) используются потоки, в других — asyncio.
* Некоторые объекты, такие как подключения к базе данных, могут требовать асинхронной инициализации и завершения работы.
* Некоторые зависимости должны быть общими для других объектов. Например, соединение с базой данных может использоваться несколькими data-mapper'ами и unit-of-work в рамках одного запроса.

На самом деле, всё это можно реализовать вручную: DI-фреймворк не является обязательным для приложения. Но разве не приятнее, когда всё просто работает "из коробки"?

В этом сравнении могут быть неточности: некоторые функции плохо описаны, но всё же присутствуют в выбранных библиотеках. Некоторые возможности можно реализовать вручную, но эта тема не о вашем коде — она о существующих библиотеках.

Обзор
===========================

.. list-table:: IoC-контейнеры
   :header-rows: 1

   * -
     - :abbr:`Области видимости (отдельный кеш для каждого "запроса"; дополнительные области видимости (scopes))`
     - :abbr:`Поддержка асинхронности`
     - :abbr:`Финализация (Зависимости корректно завершают работу при выходе из scope)`
     - :abbr:`Потокобезопасность (Безопасность при работе с потоками и асинхронными задачами)`
     - :abbr:`Автосвязывание (Упрощённая регистрация классов на основе их __init__)`
     - Данные контекста
     - :abbr:`Zero-globals (Можно использовать без глобального состояния)`
   * - `dishka <https://github.com/reagento/dishka>`_
     - ✅✅
     - ✅
     - ✅
     - ✅
     - ✅✅
     - ✅
     - ✅
   * - `di <https://github.com/adriangb/di>`_
     - ✅✅
     - ✅
     - ✅
     - ❌
     - ✅
     - ✅
     - ✅
   * - `FastAPI Depends <https://fastapi.tiangolo.com>`_
     - ✅❌
     - ✅
     - ✅
     - :abbr:`➖(Неприменимо)`
     - ✅
     - ❌
     - ✅
   * - `dependency-injector <https://github.com/ets-labs/python-dependency-injector>`_
     - ❌
     - ❌
     - ❌
     - ❌
     - ❌
     - ✅
     - ❌
   * - `injector <https://github.com/python-injector/injector>`_
     - ✅✅
     - ❌
     - ❌
     - ✅
     - ✅
     - ❌
     - ✅
   * - `svcv <https://github.com/hynek/svcs>`_
     - ❌
     - ✅
     - ✅
     - ❌
     - ❌
     - ✅
     - ✅
   * - `rodi <https://github.com/Neoteroi/rodi>`_
     - ✅❌
     - ❌
     - ❌
     - ❌
     - ✅
     - ✅
     - ✅
   * - `punq <https://github.com/bobthemighty/punq>`_
     - ✅❌
     - ❌
     - ❌
     - :abbr:`➖(Неприменимо)`
     - ✅
     - ✅
     - ✅
   * - `lagom <https://github.com/meadsteve/lagom>`_
     - ❌
     - ✅
     - ✅
     - ✅
     - ✅
     - ❌
     - ❌

**Описание:**

- **Области видимости (Scopes)** — может ли контейнер кэшировать зависимости для каждой области. Первая галочка означает поддержку области видимости на уровне запроса (request-scope). Вторая — поддержку дополнительных областей. Библиотеки часто по-разному интерпретируют эту функцию, особенно если не предоставляют финализацию, поэтому мы считаем их равнозначными.
- **Поддержка асинхронности (Async support)** — возможность использовать асинхронные функции в качестве фабрик.
- **Финализация (Finalization)** — может ли контейнер завершить работу с запрошенными зависимостями (включая их вложенные зависимости) после использования. Обычно это делается при выходе из области видимости.
- **Потокобезопасность (Concurrency-safe)** — безопасно ли использование синглтонов и кэша областей видимости в многопоточной среде или при работе с несколькими задачами asyncio. Не применимо, если контейнер не поддерживает кэширование или шаблон синглтона.
- **Автоматическое связывание (Autowiring)** — означает, что вам не нужно копировать сигнатуру метода ``__init__`` для объявления зависимости или явно связывать её с другими фабриками. Вторая галочка ставится, если можно создавать изолированные подграфы зависимостей с сохранением автоматического связывания.
- **Данные контекста (Context data)** — дополнительные данные, передаваемые в фабрики зависимостей после создания контейнера. Например, HTTP-запрос может использоваться для создания объектов с областью видимости запроса.
- **Нулевые глобальные переменные (Zero-globals)** — означает настоящий dependency injection. Если зависимости запрашиваются через глобальные переменные (иногда скрытые внутри фреймворка), то это не DI, а просто сложные фабрики. Контейнер должен быть реализован как вариант абстрактной фабрики, и должна быть возможность создавать несколько (совершенно разных) реализаций.


Почему не dependency-injector?
=======================================

Хотя проект dependency-injector довольно популярен, он не совсем решает задачи IoC-контейнера.

* Нет поддержки автосвязывания (auto-wiring) для классов. Приходится явно привязывать фабрики друг к другу.
* Нет кеширования созданных зависимостей на время запроса. Это приходится реализовывать вручную, используя thread-local или пересоздавая контейнер каждый раз.
* Финализация поддерживается только для синглтонов или при использовании декоратора ``@inject``. Вероятно, придётся пересоздавать контейнер.
* Синглтоны не потокобезопасны.
* Граф зависимостей плохо настраивается. Можно только заменять провайдеры зависимостей после их объявления.
* При внедрении зависимостей в функции требуется контейнер со всеми указанными провайдерами. Кроме того, неявно используется глобальный контейнер, что может быть проблемой в параллельных тестах.
* Довольно сложный API, который по сути предлагает альтернативный способ вызова функций.

Почему не injector?
=======================

Injector — это довольно популярный инструмент с долгой историей, но у него очень мало возможностей, и основные примеры предлагают не самые лучшие способы его использования.

* Там можно добавлять scopes (области видимости), но нет управления ими — приходится писать свою логику. Из коробки доступны только синглтоны и thread-local.
* Нет поддержки asyncio
* Нет финализации ресурсов
* Он довольно медленный. Мы выяснили, что он в 20 раз медленнее, чем ``dishka``.
* Есть автозависимости (auto-wiring). Не обязательно привязывать каждый класс к контейнеру: в некоторых случаях это может быть полезно, но усложняет поиск классов с неправильной областью видимости.

Почему не di?
======================

``di`` — это многообещающий молодой проект, у которого есть свои преимущества по сравнению с ``dishka``, но он выглядит более сложным.

* Чтобы получить зависимость, нужно передать 3 вещи: решенную зависимость, исполнитель (executor) и состояние. В ``dishka`` нужен только контейнер (и заранее известный тип зависимости).
* Области видимости (scopes) в di работают иначе, они не потокобезопасны.
* Поддерживается привязка по подклассам или по имени, но получение зависимостей более сложное.
* Не поддерживаются generic-зависимости.
* Довольно быстрый в создании зависимостей, но очень медленная инициализация. Для больших графов запуск приложения может занимать целую вечность. Например: если у вас граф из 60 классов с вложенностью 6 уровней, то в di инициализация контейнера займёт 50 секунд, а в ``dishka`` — всего 5 мс.
* Есть авто-связывание (auto-wiring), но нельзя создавать изолированные подграфы (компоненты в ``dishka``) в случае дублирования типов.
* Нет готовых интеграций с фреймворками.

Почему не FastAPI?
=========================

FastAPI Depends предоставляет простой, но эффективный API для внедрения зависимостей, но у него есть недостатки:
* Его можно использовать только внутри FastAPI.
* Он не подходит для ленивой инициализации синглтонов.
* Он смешивает Dependency Injection и декомпозицию запросов. Это приводит к некорректной OpenAPI-спецификации или даже к ошибкам в приложении.
* Каждую зависимость нужно объявлять с помощью ``Depends`` на каждом уровне приложения. В результате либо бизнес-логика содержит детали IoC-контейнера, либо приходится дублировать сигнатуры конструкторов.
* Он не очень быстрый в runtime, хотя вы можете этого никогда не заметить.
* Почти все примеры в документации игнорируют ``dependency_overrides``, хотя это главный инструмент для использования FastAPI в качестве IoC-контейнера.

Почему не svcs?
======================
При первом знакомстве ``dishka`` и ``svcs`` имеют похожий API, но ``svcs`` предлагает гораздо меньше автоматизации:

* В ``svcs`` все связи между классами создаются вручную, через вызов ``container`` внутри каждой фабрики. В ``dishka`` можно просто добавить класс, если его ``__init__`` имеет аннотации типов. Кроме того, в ``svcs`` эту информацию нельзя использовать для проверки графа зависимостей или визуализации.
* Хотя ``svcs`` кеширует зависимости, в нём нет иерархии областей видимости (scope hierarchy). Можно создать несколько контейнеров для ленивых синглтонов, но они не потокобезопасны.
* В ``svcs`` нет готовых паттернов, таких как множественные провайдеры или провайдеры на основе классов. Поэтому, если нужно сделать контейнер модульным, придётся самостоятельно придумывать решение. В ``dishka`` же можно переиспользовать ``providers``, комбинируя их для разных окружений или сценариев.

Почему не rodi?
=============================

``Rodi`` довольно простой и быстрый. Однако в нём не хватает многих полезных возможностей.

* В нём есть авто-связывание, но нет изолированных компонентов.
* Нет финализации ресурсов. Можно вручную отслеживать, что нужно освобождать, используя экземпляр ``ActivationScope``, но это придётся писать самостоятельно.
* Нет поддержки ``async``.
* Документация в основном описывает использование с ``blacksheep``.
* Фактически есть 3 типа областей видимости: singletons, scoped и transient (``cache=False`` в ``dishka``). В ``dishka`` вы можете создавать любое количество своих областей видимости.
* Ленивые singletons не потокобезопасны.
* Контекстные данные можно передавать через ``ActivationScope``, но всё равно нужно создавать фабрику для такой зависимости. В ``dishka`` для этого есть специальный маркер ``from_context``.

Почему не ...?
==============================

В мире существует множество инструментов, и мы не можем сравниваться со всеми. Некоторые из них имеют специфические функции, другие выполняют только базовые задачи. Большинство инструментов, которые мы видели, не предлагают ничего лучше простого вызова функции.

Мы открыты для новых предложений и изучаем способы сделать использование нашей библиотеки еще более удобным.
